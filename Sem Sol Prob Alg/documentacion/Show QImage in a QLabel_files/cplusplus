// API callback
related_results_labels_thumbs({"version":"1.0","encoding":"UTF-8","feed":{"xmlns":"http://www.w3.org/2005/Atom","xmlns$openSearch":"http://a9.com/-/spec/opensearchrss/1.0/","xmlns$blogger":"http://schemas.google.com/blogger/2008","xmlns$georss":"http://www.georss.org/georss","xmlns$gd":"http://schemas.google.com/g/2005","xmlns$thr":"http://purl.org/syndication/thread/1.0","id":{"$t":"tag:blogger.com,1999:blog-1629739459234463496"},"updated":{"$t":"2016-07-09T19:33:21.949+03:00"},"category":[{"term":"Java"},{"term":"Algorithms"},{"term":"cplusplus"},{"term":"Qt"},{"term":"Recursion"},{"term":"Generics"},{"term":"Data Structures"},{"term":"Binary Tree"},{"term":"Binary search algorithm"},{"term":"QGraphicsScene"},{"term":"Ubuntu"},{"term":"Boost"},{"term":"Pointer"},{"term":"QGraphicsView"},{"term":"QDialog"},{"term":"QGraphicsItem"},{"term":"J2ME"},{"term":"PL\/SQL"},{"term":"QString"},{"term":"Serialization"},{"term":"Apache POI"},{"term":"Header Files"},{"term":"Maven2"},{"term":"PostgreSQL"},{"term":"QDataStream"},{"term":"QSqlDatabase"},{"term":"QSqlQuery"},{"term":"QtSql"},{"term":"RpcGen"},{"term":"Ruby"},{"term":"Ruby on Rails"},{"term":"Software Engineering"},{"term":"socket"},{"term":".Net Framework"},{"term":"C#"},{"term":"Commons Net FtpClient"},{"term":"Dictionary"},{"term":"Dynamic-link library"},{"term":"Enumeration"},{"term":"Exceptions"},{"term":"Hibernate"},{"term":"Junit"},{"term":"Logger"},{"term":"MySQL"},{"term":"QDebug"},{"term":"QDir"},{"term":"QFileDialog"},{"term":"QImage"},{"term":"QLayout"},{"term":"QLibrary"},{"term":"QMutex"},{"term":"QRegExp"},{"term":"QSqlError"},{"term":"QStringList"},{"term":"QTest"},{"term":"QVariant"},{"term":"QXMLStreamWriter"},{"term":"Regex"},{"term":"Run-time type information"},{"term":"Unicode"},{"term":"Visual Studio IDE"}],"title":{"type":"text","$t":"Tufan Görel"},"subtitle":{"type":"html","$t":""},"link":[{"rel":"http://schemas.google.com/g/2005#feed","type":"application/atom+xml","href":"http:\/\/tufangorel.blogspot.com\/feeds\/posts\/default"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/1629739459234463496\/posts\/default\/-\/cplusplus?alt=json-in-script\u0026max-results=5"},{"rel":"alternate","type":"text/html","href":"http:\/\/tufangorel.blogspot.com\/search\/label\/cplusplus"},{"rel":"hub","href":"http://pubsubhubbub.appspot.com/"},{"rel":"next","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/1629739459234463496\/posts\/default\/-\/cplusplus\/-\/cplusplus?alt=json-in-script\u0026start-index=6\u0026max-results=5"}],"author":[{"name":{"$t":"Tufan Görel"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/02308107478813024690"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"32","height":"31","src":"http:\/\/1.bp.blogspot.com\/-8C4zN2V2Zoc\/VhgpZJnyTzI\/AAAAAAAAAdA\/dmkwYsYWV00\/s220\/profile_photo.jpg"}}],"generator":{"version":"7.00","uri":"http://www.blogger.com","$t":"Blogger"},"openSearch$totalResults":{"$t":"45"},"openSearch$startIndex":{"$t":"1"},"openSearch$itemsPerPage":{"$t":"5"},"entry":[{"id":{"$t":"tag:blogger.com,1999:blog-1629739459234463496.post-4214227190730351523"},"published":{"$t":"2015-08-11T00:12:00.002+03:00"},"updated":{"$t":"2015-11-11T16:03:16.045+02:00"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"cplusplus"},{"scheme":"http://www.blogger.com/atom/ns#","term":"Pointer"}],"title":{"type":"text","$t":"const pointer to const data in c++"},"content":{"type":"html","$t":"A pointer is a variable and it has got a value as other variable types. A pointer can be declared as a constant.\u003Cbr \/\u003E\u003Cbr \/\u003EIt is allowed to dereference a constant pointer and assign a new value to the pointed address under suitable conditions.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E1-) const pointer to data :\u003C\/b\u003E\u003Cbr \/\u003E\u003Cbr \/\u003EIn the following function \"constPtrToData()\" ptr is initially pointing to the address of the val1 which is holding the value of 10. Later constant pointer ptr is dereferenced and the value at the pointed address changed.\u003Cbr \/\u003E\u003Cbr \/\u003ETherefore, the value of val1 and val2 variables becomes the same at the end of the \"constPtrToData()\" function call.\u003Cbr \/\u003E\u003Cbr \/\u003EHowever, it is not allowed to directly change the address where the constant pointer points to.\u003Cbr \/\u003E\u003Cbr \/\u003EIf the constant pointer is assigned to the address of the second variable then a compile time error arises.\u003Cbr \/\u003E\u003Cbr \/\u003EIf you try to assign a new address to the const ptr then the following compile-time error is generated :\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E\u003Ci\u003Eerror: assignment of read-only variable 'ptr'\u003C\/i\u003E\u003C\/b\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cu\u003EThis means that you can not change the address assigned to the const pointer.\u003C\/u\u003E\u003Cbr \/\u003E\u003Cbr \/\u003ETerminal output of the \"constPtrToData()\" function shows that the initial address const ptr holds does not change, but the value stored at this address changes.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp\" name=\"code\"\u003E#include \u0026lt;iostream\u0026gt;\u003Cbr \/\u003Eusing namespace std;\u003Cbr \/\u003E\u003Cbr \/\u003Evoid constPtrToData()\u003Cbr \/\u003E{\u003Cbr \/\u003E    \/\/not allowed to change where the ptr points to\u003Cbr \/\u003E    int val1 = 10, val2 = 20;\u003Cbr \/\u003E    int *const ptr = \u0026amp;val1;\u003Cbr \/\u003E\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"ptr value = \" \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; \" address = \"\u0026lt;\u0026lt; ptr \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E\u003Cbr \/\u003E    *ptr = val2;\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"ptr value = \" \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; \" address = \"\u0026lt;\u0026lt; ptr \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"val1 value = \" \u0026lt;\u0026lt; val1 \u0026lt;\u0026lt; \" val2 value = \" \u0026lt;\u0026lt; val2 \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E\u003Cbr \/\u003E    \/\/ can not assign to constant ptr a new address\u003Cbr \/\u003E    \/\/ ptr = \u0026amp;val2;  \/\/ error: assignment of read-only variable 'ptr'\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E    constPtrToData();\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003C\/pre\u003E \u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"http:\/\/3.bp.blogspot.com\/-GiGGFl4_18w\/VckK2rwZnCI\/AAAAAAAAAWA\/6s6XjmP2meU\/s1600\/const_ptr_to_data.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" height=\"110\" src=\"http:\/\/3.bp.blogspot.com\/-GiGGFl4_18w\/VckK2rwZnCI\/AAAAAAAAAWA\/6s6XjmP2meU\/s320\/const_ptr_to_data.png\" width=\"320\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E2-) pointer to const data\u003C\/b\u003E\u003Cbr \/\u003E\u003Cbr \/\u003EA pointer can point to constant data. At this time, the address that the pointer points to can be changed but the value can not.\u003Cbr \/\u003E\u003Cbr \/\u003EFollowing compile-time error generated when you try to dereference a pointer which points to const data.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre\u003E\u003Cb style=\"font-family: 'Times New Roman'; white-space: normal;\"\u003E\u003Ci\u003Eerror: assignment of read-only location '* ptr2'\u0026nbsp;\u003C\/i\u003E\u003C\/b\u003E\u003C!--EndFragment--\u003E\u003C\/pre\u003E\u003Cbr \/\u003EMain aim of using pointer to const data is to protect the data being pointed to instead of the address of the pointer itself.\u003Cbr \/\u003E\u003Cbr \/\u003EIn the following \"ptrToConstantData()\" function, ptr2 is declared as a normal pointer which points to constant data.\u003Cbr \/\u003E\u003Cbr \/\u003EFor this case, it is allowed to change the address which pointer points to.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp\" name=\"code\"\u003E#include \u0026lt;iostream\u0026gt;\u003Cbr \/\u003Eusing namespace std;\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003Evoid ptrToConstantData()\u003Cbr \/\u003E{\u003Cbr \/\u003E    \/\/protect the value of the variable pointed to\u003Cbr \/\u003E    double val3 = 32, val4 = 45;\u003Cbr \/\u003E    const double *ptr2 = \u0026amp;val3;\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"ptr2 value = \" \u0026lt;\u0026lt; *ptr2 \u0026lt;\u0026lt; \" address = \" \u0026lt;\u0026lt; ptr2 \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E\u003Cbr \/\u003E    \/\/ can not change the value at the address ptr2 points to\u003Cbr \/\u003E    \/\/ *ptr2 = val4;   error: assignment of read-only location '* ptr2'\u003Cbr \/\u003E\u003Cbr \/\u003E    \/\/ allowed to change the address of the ptr2 points to\u003Cbr \/\u003E    ptr2 = \u0026amp;val4;\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"ptr2 value = \" \u0026lt;\u0026lt; *ptr2 \u0026lt;\u0026lt; \" address = \" \u0026lt;\u0026lt; ptr2 \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"val3 value = \" \u0026lt;\u0026lt; val3 \u0026lt;\u0026lt; \" val4 value = \" \u0026lt;\u0026lt; val4 \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E    ptrToConstantData();\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/pre\u003E\u003Cbr \/\u003EOutput of the function call is :   \u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"http:\/\/3.bp.blogspot.com\/-kCBPqxVTzug\/VckQxe6FyTI\/AAAAAAAAAWQ\/lYo1ANIg_U4\/s1600\/pointer_to_const_data.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" height=\"103\" src=\"http:\/\/3.bp.blogspot.com\/-kCBPqxVTzug\/VckQxe6FyTI\/AAAAAAAAAWQ\/lYo1ANIg_U4\/s320\/pointer_to_const_data.png\" width=\"320\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E3-) const pointer to const data\u003C\/b\u003E\u003Cbr \/\u003E\u003Cb\u003E\u003Cbr \/\u003E\u003C\/b\u003EDeclaring a constant pointer which is pointing to constant data means that you are aiming to\u0026nbsp;protect both the pointer and the data at the pointed address from being modified.\u003Cbr \/\u003E\u003Cbr \/\u003EIn this case, if you try to change the address of the pointer or dereference the pointer following error messages generated respectively :\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E\u003Ci\u003Eerror: assignment of read-only variable 'ptr3'\u003C\/i\u003E\u003C\/b\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cb\u003E\u003Ci\u003Eerror: assignment of read-only location '*(const int*)ptr3'\u003C\/i\u003E\u003C\/b\u003E\u003Cbr \/\u003E\u003Cb\u003E\u003Ci\u003E\u003Cbr \/\u003E\u003C\/i\u003E\u003C\/b\u003EFollowing \"constPtrToConstData()\" declares ptr3 as a const pointer to const int .\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp\" name=\"code\"\u003E#include \u0026lt;iostream\u0026gt;\u003Cbr \/\u003E\u003Cbr \/\u003Eusing namespace std;\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003Evoid constPtrToConstData()\u003Cbr \/\u003E{\u003Cbr \/\u003E    \/\/protect both pointer and the data from being modified\u003Cbr \/\u003E    int val1 = 10, val2 = 20;\u003Cbr \/\u003E    const int *const ptr3 = \u0026amp;val1;\u003Cbr \/\u003E\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; *ptr3 \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E\u003Cbr \/\u003E    \/\/ ptr3 = \u0026amp;val2;  \/\/ error: assignment of read-only variable 'ptr3'\u003Cbr \/\u003E    \/\/ *ptr3 = val2;  \/\/ error: assignment of read-only location '*(const int*)ptr3'\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{    \u003Cbr \/\u003E    constPtrToConstData();\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"\\n\";\u003Cbr \/\u003E\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/pre\u003EWhen the \"constPtrToConstData()\" function executed it just prints \"10\" as expected to the terminal. "},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/tufangorel.blogspot.com\/feeds\/4214227190730351523\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/tufangorel.blogspot.com\/2015\/08\/const-pointer-to-const-data-in-c.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/1629739459234463496\/posts\/default\/4214227190730351523"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/1629739459234463496\/posts\/default\/4214227190730351523"},{"rel":"alternate","type":"text/html","href":"http:\/\/tufangorel.blogspot.com\/2015\/08\/const-pointer-to-const-data-in-c.html","title":"const pointer to const data in c++"}],"author":[{"name":{"$t":"Tufan Görel"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/02308107478813024690"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"32","height":"31","src":"http:\/\/1.bp.blogspot.com\/-8C4zN2V2Zoc\/VhgpZJnyTzI\/AAAAAAAAAdA\/dmkwYsYWV00\/s220\/profile_photo.jpg"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"http:\/\/3.bp.blogspot.com\/-GiGGFl4_18w\/VckK2rwZnCI\/AAAAAAAAAWA\/6s6XjmP2meU\/s72-c\/const_ptr_to_data.png","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-1629739459234463496.post-7996146412372289159"},"published":{"$t":"2015-07-29T00:44:00.001+03:00"},"updated":{"$t":"2015-11-11T16:03:33.057+02:00"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"cplusplus"},{"scheme":"http://www.blogger.com/atom/ns#","term":"Pointer"}],"title":{"type":"text","$t":"void* universal pointer"},"content":{"type":"html","$t":"void* also known as universal pointer or generic pointer can be used to hold the address of any type assigned to it.\u003Cbr \/\u003E\u003Cbr \/\u003Evoid* universal pointer can also be used as a function argument.\u003Cbr \/\u003E\u003Cbr \/\u003EBelow example transferValues function declares two void* arguments.\u003Cbr \/\u003E\u003Cbr \/\u003EInstead of writing two different functions for int and double types only one transferValues function with void* arguments can be used.\u003Cbr \/\u003E\u003Cbr \/\u003Evoid* seems to be usable but there are type-safety related problems with void pointer.\u003Cbr \/\u003E\u003Cbr \/\u003EWith a suitable casting operation existing void* universal pointer can be converted to an appropriate type.\u003Cbr \/\u003E\u003Cbr \/\u003EBecause a void pointer can not be dereferenced directly, static_cast can be used to cast from void* to another type.\u003Cbr \/\u003E\u003Cbr \/\u003EFollowing error message is generated by the compiler if a void* is dereferenced before casting to an appropriate type.\u003Cbr \/\u003E\u003Cbr \/\u003E'void*' is not a pointer-to-object type\u003Cbr \/\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u003Cbr \/\u003E\u003Cbr \/\u003EExample void pointer project compiled with : g++ (Ubuntu 4.9.2-10ubuntu13) 4.9.2\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp\" name=\"code\"\u003E#include \u0026lt;iostream\u0026gt;\u003Cbr \/\u003Eusing namespace std;\u003Cbr \/\u003E\u003Cbr \/\u003Eenum ParamType\u003Cbr \/\u003E{\u003Cbr \/\u003E    intType,\u003Cbr \/\u003E    doubleType\u003Cbr \/\u003E};\u003Cbr \/\u003E\u003Cbr \/\u003Evoid transferValues( void* from, void* to, int size, ParamType pType)\u003Cbr \/\u003E{\u003Cbr \/\u003E\u003Cbr \/\u003E    if( pType == intType )\u003Cbr \/\u003E    {\u003Cbr \/\u003E         for (int i= 0; i\u0026lt;size; i++)\u003Cbr \/\u003E         {\u003Cbr \/\u003E             static_cast\u0026lt;int*\u0026gt;(to)[i] = static_cast\u0026lt;int*\u0026gt;(from)[i];\u003Cbr \/\u003E         }\u003Cbr \/\u003E    }\u003Cbr \/\u003E    else if( pType == doubleType )\u003Cbr \/\u003E    {\u003Cbr \/\u003E         for (int i= 0; i\u0026lt;size; i++)\u003Cbr \/\u003E         {\u003Cbr \/\u003E             static_cast\u0026lt;double*\u0026gt;(to)[i] = static_cast\u0026lt;double*\u0026gt;(from)[i];\u003Cbr \/\u003E         }\u003Cbr \/\u003E    }\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E\u003Cbr \/\u003E    int val = 5;\u003Cbr \/\u003E    void* vPtr = \u0026amp;val;\u003Cbr \/\u003E    \/\/ below line generates compile error\u003Cbr \/\u003E    \/\/ cout \u0026lt;\u0026lt; *vPtr;\u003Cbr \/\u003E    int* newVal = static_cast\u0026lt;int*\u0026gt;(vPtr);\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; *newVal \u0026lt;\u0026lt; endl;\u003Cbr \/\u003E\u003Cbr \/\u003E    double dVal = 5.2;\u003Cbr \/\u003E    vPtr = \u0026amp;dVal;\u003Cbr \/\u003E    double* newDVal = static_cast\u0026lt;double*\u0026gt;(vPtr);\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; *newDVal \u0026lt;\u0026lt; endl;\u003Cbr \/\u003E\u003Cbr \/\u003E    char cVal = 'c';\u003Cbr \/\u003E    vPtr = \u0026amp;cVal;\u003Cbr \/\u003E    char* newCVal = static_cast\u0026lt;char*\u0026gt;(vPtr);\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; *newCVal;\u003Cbr \/\u003E\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl;\u003Cbr \/\u003E\u003Cbr \/\u003E    int a[5] = { 1, 2, 1, 1, 1 };\u003Cbr \/\u003E    int b[5];\u003Cbr \/\u003E\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"Elements of array a = \";\u003Cbr \/\u003E    for( int i = 0; i\u0026lt;5; i++ )\u003Cbr \/\u003E        cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \" \";\u003Cbr \/\u003E\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \"Elements of array b before casting = \";\u003Cbr \/\u003E    for( int i = 0; i\u0026lt;5; i++ )\u003Cbr \/\u003E        cout \u0026lt;\u0026lt; b[i] \u0026lt;\u0026lt; \" \";\u003Cbr \/\u003E\u003Cbr \/\u003E    transferValues( a, b, 5, intType );\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \"Elements of array b after casting = \";\u003Cbr \/\u003E    for( int i = 0; i\u0026lt;5; i++ )\u003Cbr \/\u003E        cout \u0026lt;\u0026lt;  b[i] \u0026lt;\u0026lt; \" \";\u003Cbr \/\u003E\u003Cbr \/\u003E    double c[5] = { 2.3, 3.3, 4.3, 5.3, 6.3 };\u003Cbr \/\u003E    double d[5];\u003Cbr \/\u003E\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \"Elements of array c = \";\u003Cbr \/\u003E    for( int i = 0; i\u0026lt;5; i++ )\u003Cbr \/\u003E        cout \u0026lt;\u0026lt; c[i] \u0026lt;\u0026lt; \" \";\u003Cbr \/\u003E\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt;\"Elements of array d before casting = \";\u003Cbr \/\u003E    for( int i = 0; i\u0026lt;5; i++ )\u003Cbr \/\u003E        cout \u0026lt;\u0026lt; d[i] \u0026lt;\u0026lt; \" \";\u003Cbr \/\u003E\u003Cbr \/\u003E    transferValues( c, d, 5, doubleType );\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \"Elements of array d after casting = \";\u003Cbr \/\u003E    for( int i = 0; i\u0026lt;5; i++ )\u003Cbr \/\u003E        cout \u0026lt;\u0026lt; d[i] \u0026lt;\u0026lt; \" \";\u003Cbr \/\u003E\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl;\u003Cbr \/\u003E\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/pre\u003EAfter running the program following terminal output displayed.  \u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-uMOpOaxnNB4\/Vbf3jcxj19I\/AAAAAAAAAVU\/akSa_hCoNIk\/s1600\/void_pointer.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" height=\"132\" src=\"http:\/\/2.bp.blogspot.com\/-uMOpOaxnNB4\/Vbf3jcxj19I\/AAAAAAAAAVU\/akSa_hCoNIk\/s400\/void_pointer.png\" width=\"400\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/tufangorel.blogspot.com\/feeds\/7996146412372289159\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/tufangorel.blogspot.com\/2015\/07\/void-universal-pointer-static-casting-in-c.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/1629739459234463496\/posts\/default\/7996146412372289159"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/1629739459234463496\/posts\/default\/7996146412372289159"},{"rel":"alternate","type":"text/html","href":"http:\/\/tufangorel.blogspot.com\/2015\/07\/void-universal-pointer-static-casting-in-c.html","title":"void* universal pointer"}],"author":[{"name":{"$t":"Tufan Görel"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/02308107478813024690"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"32","height":"31","src":"http:\/\/1.bp.blogspot.com\/-8C4zN2V2Zoc\/VhgpZJnyTzI\/AAAAAAAAAdA\/dmkwYsYWV00\/s220\/profile_photo.jpg"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"http:\/\/2.bp.blogspot.com\/-uMOpOaxnNB4\/Vbf3jcxj19I\/AAAAAAAAAVU\/akSa_hCoNIk\/s72-c\/void_pointer.png","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-1629739459234463496.post-8549828937219593298"},"published":{"$t":"2015-07-25T01:48:00.003+03:00"},"updated":{"$t":"2015-11-11T16:03:43.909+02:00"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"cplusplus"}],"title":{"type":"text","$t":"toLower and toUpper Character Functions in C++ without using string.h and ctype.h"},"content":{"type":"html","$t":"\u003Ca href=\"http:\/\/www.cplusplus.com\/reference\/string\/\"\u003Estring.h\u003C\/a\u003E and \u003Ca href=\"http:\/\/www.cplusplus.com\/reference\/cctype\/\"\u003Ectype.h\u003C\/a\u003E libraries have got functions defined for converting characters from upper case to lower case and vice versa.\u003Cbr \/\u003E\u003Cbr \/\u003ESample functions below achieves in a c program following requirements :\u003Cbr \/\u003E\u003Cbr \/\u003E1- convert a given character from lower case to upper case character\u003Cbr \/\u003E2- convert a given character from upper case to lower case character\u003Cbr \/\u003E3- convert a given whole string from lower case to upper case string\u003Cbr \/\u003E4- convert a given whole string from upper case to lower case string\u003Cbr \/\u003E\u003Cbr \/\u003Ewith the following constraints :\u003Cbr \/\u003E\u003Cbr \/\u003E1- All letters are English alphabet letters\u003Cbr \/\u003E2- There is no space in the input\u003Cbr \/\u003E3- Only character input is assumed\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003EMain rule to remember when converting case for letters is :\u003Cbr \/\u003E\u003Cbr \/\u003EUpper case character = Lower case character - (\u003Cspan style=\"color: green;\"\u003E'a'\u003C\/span\u003E-\u003Cspan style=\"color: green;\"\u003E'A'\u003C\/span\u003E);\u003Cbr \/\u003ELower case character = Upper case character + (\u003Cspan style=\"color: green;\"\u003E'a'\u003C\/span\u003E-\u003Cspan style=\"color: green;\"\u003E'A'\u003C\/span\u003E);\u003Cbr \/\u003E\u003Cbr \/\u003EHere the difference (\u003Cspan style=\"color: green;\"\u003E'a'\u003C\/span\u003E-\u003Cspan style=\"color: green;\"\u003E'A'\u003C\/span\u003E) corresponds to 32.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp\" name=\"code\"\u003E#include \u0026lt;stdio.h\u0026gt;\u003Cbr \/\u003E\u003Cbr \/\u003Echar charToLower(const char\u0026amp; cUpper)\u003Cbr \/\u003E{\u003Cbr \/\u003E    if(cUpper\u0026gt;='A' \u0026amp;\u0026amp; cUpper\u0026lt;='Z')\u003Cbr \/\u003E        return cUpper+('a'-'A');\u003Cbr \/\u003E    else\u003Cbr \/\u003E        return cUpper;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Echar charToUpper(const char\u0026amp; cLower)\u003Cbr \/\u003E{\u003Cbr \/\u003E    if(cLower\u0026gt;='a' \u0026amp;\u0026amp; cLower\u0026lt;='z')\u003Cbr \/\u003E        return cLower-('a'-'A');\u003Cbr \/\u003E    else\u003Cbr \/\u003E        return cLower;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Echar* strToLower( char strUpper[] )\u003Cbr \/\u003E{\u003Cbr \/\u003E    int i = 0;\u003Cbr \/\u003E    while(strUpper[i] != '\\0')\u003Cbr \/\u003E        i++;\u003Cbr \/\u003E\u003Cbr \/\u003E    char* strLower = new char[i];\u003Cbr \/\u003E    i=0;\u003Cbr \/\u003E    while( strUpper[i] != '\\0' )\u003Cbr \/\u003E    {\u003Cbr \/\u003E        if(strUpper[i]\u0026gt;='A' \u0026amp;\u0026amp; strUpper[i]\u0026lt;='Z')\u003Cbr \/\u003E            strLower[i] = strUpper[i]+('a'-'A');\u003Cbr \/\u003E        i++;\u003Cbr \/\u003E    }\u003Cbr \/\u003E    return strLower;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Echar* strToUpper( char strLower[] )\u003Cbr \/\u003E{\u003Cbr \/\u003E    int i=0;\u003Cbr \/\u003E    while(strLower[i] != '\\0')\u003Cbr \/\u003E        i++;\u003Cbr \/\u003E\u003Cbr \/\u003E    char* strUpper = new char[i];\u003Cbr \/\u003E    i=0;\u003Cbr \/\u003E    while( strLower[i] != '\\0' )\u003Cbr \/\u003E    {\u003Cbr \/\u003E        if( strLower[i]\u0026gt;='a' \u0026amp;\u0026amp; strLower[i]\u0026lt;='z')\u003Cbr \/\u003E            strUpper[i] = strLower[i]-('a'-'A');\u003Cbr \/\u003E        i++;\u003Cbr \/\u003E    }\u003Cbr \/\u003E    return strUpper;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E    char upperCaseChar = 'C';\u003Cbr \/\u003E    char lowerCaseChar = charToLower(upperCaseChar);\u003Cbr \/\u003E    printf(\"Upper Case Character : %c \\n\", upperCaseChar);\u003Cbr \/\u003E    printf(\"Lower Case Character : %c \\n\\n\", lowerCaseChar);\u003Cbr \/\u003E\u003Cbr \/\u003E    char lowerTestChar = 'f';\u003Cbr \/\u003E    char upperTestChar = charToUpper(lowerTestChar);\u003Cbr \/\u003E    printf(\"Lower Case Character : %c \\n\", lowerTestChar);\u003Cbr \/\u003E    printf(\"Upper Case Character : %c \\n\\n\", upperTestChar);\u003Cbr \/\u003E\u003Cbr \/\u003E    char upperCaseString[] = \"TRKSH\";\u003Cbr \/\u003E    char* lowerCaseString = strToLower(upperCaseString);\u003Cbr \/\u003E    printf(\"Upper Case String : %s \\n\", upperCaseString);\u003Cbr \/\u003E    printf(\"Lower Case String : %s \\n\\n\", lowerCaseString);\u003Cbr \/\u003E    delete[] lowerCaseString;\u003Cbr \/\u003E\u003Cbr \/\u003E    char lowerCaseTestString[] = \"trksh\";\u003Cbr \/\u003E    char* upperCaseTestString = strToUpper(lowerCaseTestString);\u003Cbr \/\u003E    printf(\"Lower Case String : %s \\n\", lowerCaseTestString);\u003Cbr \/\u003E    printf(\"Upper Case String : %s \\n\\n\", upperCaseTestString);\u003Cbr \/\u003E    delete[] upperCaseTestString;\u003Cbr \/\u003E\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/pre\u003EAfter running the program following terminal output displayed.  \u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-BZVXCYCysHU\/VbK-9fKEOpI\/AAAAAAAAAVE\/AHgftsQEtoM\/s1600\/console_output.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" height=\"157\" src=\"http:\/\/2.bp.blogspot.com\/-BZVXCYCysHU\/VbK-9fKEOpI\/AAAAAAAAAVE\/AHgftsQEtoM\/s200\/console_output.png\" width=\"200\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/tufangorel.blogspot.com\/feeds\/8549828937219593298\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/tufangorel.blogspot.com\/2015\/07\/tolower-and-toupper-character-functions-in-c-without-using-string.h-or-ctype.h.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/1629739459234463496\/posts\/default\/8549828937219593298"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/1629739459234463496\/posts\/default\/8549828937219593298"},{"rel":"alternate","type":"text/html","href":"http:\/\/tufangorel.blogspot.com\/2015\/07\/tolower-and-toupper-character-functions-in-c-without-using-string.h-or-ctype.h.html","title":"toLower and toUpper Character Functions in C++ without using string.h and ctype.h"}],"author":[{"name":{"$t":"Tufan Görel"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/02308107478813024690"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"32","height":"31","src":"http:\/\/1.bp.blogspot.com\/-8C4zN2V2Zoc\/VhgpZJnyTzI\/AAAAAAAAAdA\/dmkwYsYWV00\/s220\/profile_photo.jpg"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"http:\/\/2.bp.blogspot.com\/-BZVXCYCysHU\/VbK-9fKEOpI\/AAAAAAAAAVE\/AHgftsQEtoM\/s72-c\/console_output.png","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-1629739459234463496.post-5488184912779182802"},"published":{"$t":"2015-07-24T00:06:00.001+03:00"},"updated":{"$t":"2015-11-11T16:03:53.948+02:00"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"Algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"cplusplus"}],"title":{"type":"text","$t":"Palindrome String Check in C++ without using string.h"},"content":{"type":"html","$t":"\u003Ca href=\"https:\/\/en.wikipedia.org\/wiki\/Palindrome\" target=\"_blank\"\u003EPalindrome\u003C\/a\u003E check for a given string is very popular starting exercise for new programmers. It has got many implementations in Java and C++. Most of the implementations use existing String class in Java or string.h header in C++.\u003Cbr \/\u003E\u003Cbr \/\u003EFollowing string palindrome check function in c++ without using string.h works with the constraints :\u003Cbr \/\u003E\u003Cbr \/\u003E- strings that do not contain any space\u003Cbr \/\u003E- strings just contain English alphabet characters\u003Cbr \/\u003E- strings with more than 3 characters\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp\" name=\"code\"\u003E#include \u0026lt;stdio.h\u0026gt;\u003Cbr \/\u003E\u003Cbr \/\u003Eint isPalindrome( const char* arr )\u003Cbr \/\u003E{\u003Cbr \/\u003E    int stringLength = 0;\u003Cbr \/\u003E    int index = 0;\u003Cbr \/\u003E    while(arr[index]!='\\0')\u003Cbr \/\u003E    {\u003Cbr \/\u003E        ++stringLength;\u003Cbr \/\u003E        ++index;\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    if( stringLength \u0026gt;= 0 \u0026amp;\u0026amp; stringLength \u0026lt;=2 )\u003Cbr \/\u003E        return 0;\u003Cbr \/\u003E\u003Cbr \/\u003E    for(int i = 0; i\u0026lt;stringLength\/2; i++)\u003Cbr \/\u003E    {\u003Cbr \/\u003E        if(arr[i] != arr[stringLength-1-i])\u003Cbr \/\u003E            return 0;\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    return 1;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E    const char* stringToCheck1 = \"aba\";\u003Cbr \/\u003E    int res = isPalindrome(stringToCheck1);\u003Cbr \/\u003E    if(res)\u003Cbr \/\u003E        printf(\"%s is palindrome\\n\", stringToCheck1);\u003Cbr \/\u003E    else\u003Cbr \/\u003E        printf(\"%s is not palindrome\\n\",stringToCheck1);\u003Cbr \/\u003E\u003Cbr \/\u003E    const char* stringToCheck2 = \"abba\";\u003Cbr \/\u003E    res = isPalindrome(stringToCheck2);\u003Cbr \/\u003E    if(res)\u003Cbr \/\u003E        printf(\"%s is palindrome\\n\",stringToCheck2);\u003Cbr \/\u003E    else\u003Cbr \/\u003E        printf(\"%s is not palindrome\\n\",stringToCheck2);\u003Cbr \/\u003E\u003Cbr \/\u003E    const char* stringToCheck3 = \"abccccba\";\u003Cbr \/\u003E    res = isPalindrome(stringToCheck3);\u003Cbr \/\u003E    if(res)\u003Cbr \/\u003E        printf(\"%s is palindrome\\n\",stringToCheck3);\u003Cbr \/\u003E    else\u003Cbr \/\u003E        printf(\"%s is not palindrome\\n\",stringToCheck3);\u003Cbr \/\u003E\u003Cbr \/\u003E    const char* stringToCheck4 = \"abcc111211ccba\";\u003Cbr \/\u003E    res = isPalindrome(stringToCheck4);\u003Cbr \/\u003E    if(res)\u003Cbr \/\u003E        printf(\"%s is palindrome\\n\",stringToCheck4);\u003Cbr \/\u003E    else\u003Cbr \/\u003E        printf(\"%s is not palindrome\\n\",stringToCheck4);\u003Cbr \/\u003E\u003Cbr \/\u003E    const char* stringToCheck5 = \"\";\u003Cbr \/\u003E    res = isPalindrome(stringToCheck5);\u003Cbr \/\u003E    if(res)\u003Cbr \/\u003E        printf(\"%s is palindrome\\n\",stringToCheck5);\u003Cbr \/\u003E    else\u003Cbr \/\u003E        printf(\"%s is not palindrome\\n\",stringToCheck5);\u003Cbr \/\u003E\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/pre\u003EAfter executing above main function following terminal output is produced. \u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"http:\/\/1.bp.blogspot.com\/-gnRFxQylV2U\/VbFXBCtlfkI\/AAAAAAAAAU0\/Y1raHR_bPV8\/s1600\/palindrome_result.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" height=\"93\" src=\"http:\/\/1.bp.blogspot.com\/-gnRFxQylV2U\/VbFXBCtlfkI\/AAAAAAAAAU0\/Y1raHR_bPV8\/s320\/palindrome_result.png\" width=\"320\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/tufangorel.blogspot.com\/feeds\/5488184912779182802\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/tufangorel.blogspot.com\/2015\/07\/palindrome-string-check-in-c-without-using-string.h.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/1629739459234463496\/posts\/default\/5488184912779182802"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/1629739459234463496\/posts\/default\/5488184912779182802"},{"rel":"alternate","type":"text/html","href":"http:\/\/tufangorel.blogspot.com\/2015\/07\/palindrome-string-check-in-c-without-using-string.h.html","title":"Palindrome String Check in C++ without using string.h"}],"author":[{"name":{"$t":"Tufan Görel"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/02308107478813024690"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"32","height":"31","src":"http:\/\/1.bp.blogspot.com\/-8C4zN2V2Zoc\/VhgpZJnyTzI\/AAAAAAAAAdA\/dmkwYsYWV00\/s220\/profile_photo.jpg"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"http:\/\/1.bp.blogspot.com\/-gnRFxQylV2U\/VbFXBCtlfkI\/AAAAAAAAAU0\/Y1raHR_bPV8\/s72-c\/palindrome_result.png","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-1629739459234463496.post-6686801563503059165"},"published":{"$t":"2015-07-23T01:07:00.001+03:00"},"updated":{"$t":"2015-11-11T16:04:03.072+02:00"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"Algorithms"},{"scheme":"http://www.blogger.com/atom/ns#","term":"cplusplus"},{"scheme":"http://www.blogger.com/atom/ns#","term":"Recursion"}],"title":{"type":"text","$t":"Iterative and Recursive Factorial Functions in C++"},"content":{"type":"html","$t":"\u003Ca href=\"https:\/\/en.wikipedia.org\/wiki\/Factorial\" target=\"_blank\"\u003EFactorial\u003C\/a\u003E function is defined as a function which multiplies a given number by every number below it until 1.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cspan style=\"background-color: white; font-family: Verdana, Arial, sans-serif; font-size: 13.2799997329712px;\"\u003EFor example 5!= 5*4*3*2*1=120.\u003C\/span\u003E\u003Cbr \/\u003E\u003Cspan style=\"background-color: white; font-family: Verdana, Arial, sans-serif; font-size: 13.2799997329712px;\"\u003E\u003Cbr \/\u003E\u003C\/span\u003EIn C++, factorial function can be implemented in an iterative or recursive way.\u003Cbr \/\u003E\u003Cbr \/\u003EFor big numbers, return value of factorial functions are declared as unsigned long long.\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cpre class=\"brush:cpp\" name=\"code\"\u003E#include \u0026lt;iostream\u0026gt;\u003Cbr \/\u003Eusing namespace std;\u003Cbr \/\u003E\u003Cbr \/\u003Eunsigned long long iterativeFactorial( const unsigned int\u0026amp; value )\u003Cbr \/\u003E{\u003Cbr \/\u003E    unsigned long long result=1;\u003Cbr \/\u003E    unsigned long long i=1;\u003Cbr \/\u003E    while(i\u0026lt;=value)\u003Cbr \/\u003E    {\u003Cbr \/\u003E        result *= i++;\u003Cbr \/\u003E    }\u003Cbr \/\u003E\u003Cbr \/\u003E    return result;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Eunsigned long long recursiveFactorial( const unsigned int\u0026amp; value )\u003Cbr \/\u003E{\u003Cbr \/\u003E    if( value == 1 || value == 0 )\u003Cbr \/\u003E        return 1;\u003Cbr \/\u003E    return value*recursiveFactorial(value-1);\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003Eint main()\u003Cbr \/\u003E{\u003Cbr \/\u003E    const unsigned long value = 20;\u003Cbr \/\u003E    unsigned long long iterativeFactorialResult = iterativeFactorial( value );\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"Iterative Factorial Result : \"\u0026lt;\u0026lt; iterativeFactorialResult \u0026lt;\u0026lt; endl;\u003Cbr \/\u003E\u003Cbr \/\u003E    unsigned long long recursiveFactorialResult = recursiveFactorial( value );\u003Cbr \/\u003E    cout \u0026lt;\u0026lt; \"Recursive Factorial Result : \"\u0026lt;\u0026lt; recursiveFactorialResult \u0026lt;\u0026lt; endl;\u003Cbr \/\u003E\u003Cbr \/\u003E    return 0;\u003Cbr \/\u003E}\u003Cbr \/\u003E\u003Cbr \/\u003E\u003C\/pre\u003EBoth factorial functions in C++ source code were tested with the same value = 20 and the following result is achieved. \u003Cbr \/\u003E\u003Cbr \/\u003E\u003Cdiv class=\"separator\" style=\"clear: both; text-align: center;\"\u003E\u003Ca href=\"http:\/\/2.bp.blogspot.com\/-D__S2PyxmBI\/VbAUBFImz4I\/AAAAAAAAAUk\/CMZwCwyomZ8\/s1600\/factorial_result.png\" imageanchor=\"1\" style=\"margin-left: 1em; margin-right: 1em;\"\u003E\u003Cimg border=\"0\" height=\"36\" src=\"http:\/\/2.bp.blogspot.com\/-D__S2PyxmBI\/VbAUBFImz4I\/AAAAAAAAAUk\/CMZwCwyomZ8\/s320\/factorial_result.png\" width=\"320\" \/\u003E\u003C\/a\u003E\u003C\/div\u003E\u003Cbr \/\u003E"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http:\/\/tufangorel.blogspot.com\/feeds\/6686801563503059165\/comments\/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http:\/\/tufangorel.blogspot.com\/2015\/07\/iterative-and-recursive-factorial-functions-in-c.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/1629739459234463496\/posts\/default\/6686801563503059165"},{"rel":"self","type":"application/atom+xml","href":"http:\/\/www.blogger.com\/feeds\/1629739459234463496\/posts\/default\/6686801563503059165"},{"rel":"alternate","type":"text/html","href":"http:\/\/tufangorel.blogspot.com\/2015\/07\/iterative-and-recursive-factorial-functions-in-c.html","title":"Iterative and Recursive Factorial Functions in C++"}],"author":[{"name":{"$t":"Tufan Görel"},"uri":{"$t":"http:\/\/www.blogger.com\/profile\/02308107478813024690"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"32","height":"31","src":"http:\/\/1.bp.blogspot.com\/-8C4zN2V2Zoc\/VhgpZJnyTzI\/AAAAAAAAAdA\/dmkwYsYWV00\/s220\/profile_photo.jpg"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"http:\/\/2.bp.blogspot.com\/-D__S2PyxmBI\/VbAUBFImz4I\/AAAAAAAAAUk\/CMZwCwyomZ8\/s72-c\/factorial_result.png","height":"72","width":"72"},"thr$total":{"$t":"0"}}]}});